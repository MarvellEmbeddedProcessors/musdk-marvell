/* File token_builder_core.c
   code generated by tbgen.py */

/*****************************************************************************
Copyright (c) 2008-2016 INSIDE Secure B.V.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
  * Neither the name of INSIDE Secure B.V. nor the
    names of its contributors may be used to endorse or promote products
    derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
****************************************************************************/


/*----------------------------------------------------------------------------
 * This module implements (provides) the following interface(s):
 */

#include "token_builder.h"

/*----------------------------------------------------------------------------
 * This module uses (requires) the following interface(s):
 */

#include "c_token_builder.h"
#include "basic_defs.h"
#include "token_builder_internal.h"
#include "token_builder_macros.h"

#include "log.h"

TokenBuilder_Status_t
TokenBuilder_GetSize(
    const void * const TokenContext_p,
    unsigned int * const TokenWord32Count_p
    )
{
    const TokenBuilder_Context_t *TokenContext_Internal_p =
        (const TokenBuilder_Context_t*)TokenContext_p;
#if TKB_HAVE_CRYPTO_WIRELESS == 1u || 1
    uint32_t proto;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t seq_offset;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u) || (TKB_HAVE_PROTO_SSLTLS == 1u && !TKB_SINGLE_PASS_SSLTLS == 1u) || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t ivlen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t icvlen;
#endif
    uint32_t ivhandling;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t extseq;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t antireplay;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t upd_handling;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u) || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t cipher_is_aes;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen;
#endif

#ifdef TKB_STRICT_ARGS_CHECK
    if (TokenWord32Count_p == NULL || TokenContext_p == NULL)
    {
        LOG_CRIT("TokenBuilder_GetSize: NULL pointer supplied\n");
        return TKB_INVALID_PARAMETER;
    }
#endif

    *TokenWord32Count_p = TKB_TOKEN_HEADER_WORD_COUNT;

    *TokenWord32Count_p += 2u;
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
    proto = EVAL_proto();
    if (proto >= 25u)
    {
        if (proto <= 26u)
        {
            *TokenWord32Count_p += 1u;
        }
    }
#endif
    ivhandling = EVAL_ivhandling();
    if (ivhandling >= 8u)
    {
        if (ivhandling < 10u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (ivhandling > 13u)
        {
            *TokenWord32Count_p += 4u;
        }
        else if (ivhandling == 10u)
        {
            *TokenWord32Count_p += 4u;
        }
        else if (ivhandling == 11u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
    }
    *TokenWord32Count_p += 1u;
    proto = EVAL_proto();
    switch(proto)
    {
    case 0: /* esp_out */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (ivhandling == 2u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 1: /* esp_in */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq != 1u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 1u;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
                if (extseq > 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 2: /* esp_out_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        *TokenWord32Count_p += 5u;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 3u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
        }
        *TokenWord32Count_p += 9u;
#else
#endif
        break;
    case 3: /* esp_in_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        *TokenWord32Count_p += 6u;
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 3u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
        }
        *TokenWord32Count_p += 5u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
            if (extseq > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 4: /* esp_out_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
#else
#endif
        break;
    case 5: /* esp_in_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
        *TokenWord32Count_p += 5u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
            if (extseq > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 6: /* esp_out_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
#else
#endif
        break;
    case 7: /* esp_in_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
        *TokenWord32Count_p += 5u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
            if (extseq > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 8: /* ssltls_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 3u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 6u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            *TokenWord32Count_p += 3u;
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 4u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 4: /* upd_blk */
            *TokenWord32Count_p += 4u;
            break;
        }
#else
#endif
        break;
    case 9: /* ssltls_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
#if TKB_SINGLE_PASS_SSLTLS == 1u
        upd_handling = EVAL_upd_handling();
        if (upd_handling <= 1u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 4u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
            }
            *TokenWord32Count_p += 5u;
            switch(upd_handling)
            {
            case 0: /* upd_null */
                *TokenWord32Count_p += 1u;
                if (extseq == 0u)
                {
                    *TokenWord32Count_p += 2u;
                }
                else if (extseq == 1u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                break;
            case 1: /* upd_arc4 */
                *TokenWord32Count_p += 5u;
                break;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
            cipher_is_aes = EVAL_cipher_is_aes();
            if (cipher_is_aes == 0u)
            {
                *TokenWord32Count_p += 6u;
            }
            else
            {
                *TokenWord32Count_p += 10u;
            }
            *TokenWord32Count_p += 2u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 4u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
            }
            *TokenWord32Count_p += 2u;
            ivlen = EVAL_ivlen();
            if (ivlen > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 3u;
            switch(upd_handling)
            {
            case 2: /* upd_iv2 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 2u;
                break;
            case 3: /* upd_iv4 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 2u;
                break;
            case 4: /* upd_blk */
                if (extseq == 0u)
                {
                    *TokenWord32Count_p += 2u;
                }
                else if (extseq == 1u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                break;
            }
        }
#else
        *TokenWord32Count_p += 1u;
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 4u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
        }
        *TokenWord32Count_p += 3u;
        ivlen = EVAL_ivlen();
        if (ivlen > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            *TokenWord32Count_p += 1u;
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else if (extseq == 1u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 5u;
            break;
        case 2: /* upd_iv2 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 3: /* upd_iv4 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 4: /* upd_blk */
            *TokenWord32Count_p += 1u;
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 2u;
            }
            else if (extseq == 1u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            break;
        }
#endif
#else
#endif
        break;
    case 21: /* ssltls_gcm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 4u;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 5u;
        if (extseq != 0u)
        {
            if (hstatelen != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 5u;
#else
#endif
        break;
    case 22: /* ssltls_gcm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 4u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (extseq == 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 10: /* basic_crypto */
#if TKB_HAVE_PROTO_BASIC == 1u
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 2u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 11: /* basic_hash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen > 16u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
#else
#endif
        break;
    case 14: /* basic_crypthash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 4u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen > 16u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 2u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 15: /* basic_out_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 2u;
        if (ivhandling == 5u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 25u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 16: /* basic_in_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 2u;
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 25u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 17: /* basic_out_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        default:
            *TokenWord32Count_p += 1u;
            ;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 18: /* basic_in_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        default:
            *TokenWord32Count_p += 1u;
            ;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 19: /* basic_out_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        default:
            *TokenWord32Count_p += 2u;
            ;
        }
        *TokenWord32Count_p += 1u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 20: /* basic_in_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        default:
            *TokenWord32Count_p += 2u;
            ;
        }
        *TokenWord32Count_p += 1u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 23: /* basic_xts_crypto */
#if TKB_HAVE_CRYPTO_XTS == 1u
        *TokenWord32Count_p += 5u;
        switch(ivhandling)
        {
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 24: /* basic_kasumi_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        *TokenWord32Count_p += 3u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 25: /* basic_snow_hash */
    case 26: /* basic_zuc_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        *TokenWord32Count_p += 5u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 27: /* basic_hashenc */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 3u;
#else
#endif
        break;
    case 28: /* basic_dechash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 1u;
        cipher_is_aes = EVAL_cipher_is_aes();
        if (cipher_is_aes == 0u)
        {
            *TokenWord32Count_p += 6u;
        }
        else
        {
            *TokenWord32Count_p += 10u;
        }
        *TokenWord32Count_p += 21u;
        ivlen = EVAL_ivlen();
        if (ivlen > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 4u;
#else
#endif
        break;
    case 12: /* srtp_out */
#if TKB_HAVE_PROTO_SRTP == 1u
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
#else
#endif
        break;
    case 13: /* srtp_in */
#if TKB_HAVE_PROTO_SRTP == 1u
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            *TokenWord32Count_p += 1u;
            if (antireplay > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
            if (antireplay > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
#else
#endif
        break;
    default:
        ;
    }


   return TKB_STATUS_OK;
}


TokenBuilder_Status_t
TokenBuilder_BuildToken(
    const void * const TokenContext_p,
    const uint8_t *const Packet_p,
    const uint32_t PacketByteCount,
    const TokenBuilder_Params_t * const TKBParams_p,
    void * const Token_p,
    uint32_t * const TokenWord32Count_p,
    uint32_t * const TokenHeaderWord_p)
{
    uint32_t *tp = (uint32_t*)Token_p;
    const TokenBuilder_Context_t *TokenContext_Internal_p =
        (const TokenBuilder_Context_t*)TokenContext_p;
    uint32_t proto;
    uint32_t packetsize;
    uint32_t bypass;
#if TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t nextheader;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t pad_remainder;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t pad_blocksize;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t pad_bytes;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && !TKB_SINGLE_PASS_SSLTLS == 1u)
    uint32_t pad_bytes_in;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t seq_offset;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t iv_offset;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t ivlen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t icvlen;
#endif
    uint32_t ivhandling;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t extseq;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t salt;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_salt;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t paylen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swaplen;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swap_fraglen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t hashpad;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_pkt;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_tkn;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_out;
#endif
#if TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t swap_j;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_swaplen;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_swap;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadpad;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_hashpad;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t antireplay;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t upd_handling;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u) || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t cipher_is_aes;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u
    uint32_t appendhash;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t pad_bytes_basic;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t pad_bytes_hashenc;
#endif
#if TKB_HAVE_PROTO_SRTP == 1u
    uint32_t srtp_offset;
#endif
#if TKB_HAVE_PROTO_SRTP == 1u
    uint32_t srtp_swaproc;
#endif
    uint32_t srtp_iv0;
    uint32_t srtp_iv1;
    uint32_t srtp_iv2;
    uint32_t srtp_iv3;
    uint32_t count;
    uint32_t bearer_dir_fresh;
    uint32_t per_packet_options;
    uint32_t cw0;
    uint32_t cw1;
    const uint8_t *iv;
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u) || TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *ssltls_lastblock;
#endif
#if (TKB_HAVE_PROTO_SSLTLS == 1u && TKB_SINGLE_PASS_SSLTLS == 1u) || TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *ssltls_lastword;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *aad;
#endif

    IDENTIFIER_NOT_USED(Packet_p);
#ifdef TKB_STRICT_ARGS_CHECK
    if (TokenContext_p == NULL || Token_p == NULL ||
        TokenWord32Count_p == NULL ||
        (TokenHeaderWord_p == NULL && TKB_TOKEN_HEADER_WORD_COUNT == 0))
    {
        LOG_CRIT("TokenBuilder: NULL pointer supplied\n");
        return TKB_INVALID_PARAMETER;
    }
#endif

    if (TokenHeaderWord_p != NULL)
        *TokenHeaderWord_p = EVAL_TokenHeaderWord();
#if TKB_TOKEN_HEADER_WORD_COUNT > 0
    {
        unsigned int i;
        *tp++ = EVAL_TokenHeaderWord();
        for (i = 0; i < TKB_TOKEN_HEADER_WORD_COUNT - 1; i++)
        {
            *tp++ = 0;
        }
    }
#endif

    per_packet_options = EVAL_per_packet_options();
    if (per_packet_options != 0u)
    {
        /* DATA32 cw0 + per_packet_options */
        cw0 = EVAL_cw0();
        *tp++=0x00000000 | ((cw0+per_packet_options)&0xffffffffu)<<0;
        /* DATA32 cw1 */
        cw1 = EVAL_cw1();
        *tp++=0x00000000 | ((cw1)&0xffffffffu)<<0;
    }
    proto = EVAL_proto();
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
    if (proto >= 25u)
    {
        if (proto <= 26u)
        {
            /* DATA32 nextheader   ; Specify number of valid bits in last byte for */
            nextheader = EVAL_nextheader();
            *tp++=0x00000000 | ((nextheader)&0xffffffffu)<<0;
        }
    }
#endif
    ivhandling = EVAL_ivhandling();
    if (ivhandling >= 8u)
    {
        if (ivhandling < 10u)
        {
            iv = EVAL_iv();
            TokenBuilder_CopyBytes(tp, iv, 8);
            tp += 2;
        }
        else if (ivhandling > 13u)
        {
            iv = EVAL_iv();
            TokenBuilder_CopyBytes(tp, iv, 16);
            tp += 4;
        }
        else if (ivhandling == 10u)
        {
            /* DATA32 srtp_iv0 */
            srtp_iv0 = EVAL_srtp_iv0();
            *tp++=0x00000000 | ((srtp_iv0)&0xffffffffu)<<0;
            /* DATA32 srtp_iv1 */
            srtp_iv1 = EVAL_srtp_iv1();
            *tp++=0x00000000 | ((srtp_iv1)&0xffffffffu)<<0;
            /* DATA32 srtp_iv2 */
            srtp_iv2 = EVAL_srtp_iv2();
            *tp++=0x00000000 | ((srtp_iv2)&0xffffffffu)<<0;
            /* DATA32 srtp_iv3 */
            srtp_iv3 = EVAL_srtp_iv3();
            *tp++=0x00000000 | ((srtp_iv3)&0xffffffffu)<<0;
        }
        else if (ivhandling == 11u)
        {
            /* DATA32 count */
            count = EVAL_count();
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            bearer_dir_fresh = EVAL_bearer_dir_fresh();
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        }
        else
        {
            /* DATA32 count */
            count = EVAL_count();
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            bearer_dir_fresh = EVAL_bearer_dir_fresh();
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
            /* DATA32 count */
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        }
    }
    bypass = EVAL_bypass();
    if (bypass > 0u)
    {
        if (proto != 9u)
        {
            if (proto != 28u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
        }
    }
    packetsize = EVAL_packetsize();
    if (packetsize > 131071u)
    {
        LOG_WARN("TokenBuilder: bad packet, too long\n");
        return TKB_BAD_PACKET;
    }
    switch(proto)
    {
    case 0: /* esp_out */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound\n");
            return TKB_BAD_PACKET;
        }
        if (ivhandling == 2u)
        {
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x23a80000 | ((ivlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,8+ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x23900000 | ((8u+ivlen)&0x1ffffu)<<0;
        }
        /* DIR      CRYPTHASH,packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
                nextheader = EVAL_nextheader();
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST */
                nextheader = EVAL_nextheader();
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2f200000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
                /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2,4,LASTHASH */
                *tp++=0x224a0000 | ((4u)&0x1ffffu)<<0;
            }
            /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      CRYPT,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASHPKT */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2d260000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        }
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        extseq = EVAL_extseq();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 1: /* esp_in */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound\n");
            return TKB_BAD_PACKET;
        }
        if (ivhandling == 0u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8 */
            *tp++=0x42900000 | ((8u)&0x1ffffu)<<0;
            /* RETR     HASHONLY,ORIG_IV1,ivlen */
            *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,8+ivlen */
            *tp++=0x42900000 | ((8u+ivlen)&0x1ffffu)<<0;
        }
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq != 1u)
            {
                /* DIR   CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
                *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR   CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST */
                *tp++=0x0f000000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
                /* INS   HASHONLY, ORIG_EXTSEQNUM_RES2,4,LASTHASH */
                *tp++=0x224a0000 | ((4u)&0x1ffffu)<<0;
            }
            /* RETR  NONE,ORIG_HASH,icvlen,LASTHASHPKT */
            *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* VERIFY   icvlen,S,SP,P,H */
                *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
                if (extseq > 0u)
                {
                    /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
                }
                else
                {
                    /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
                }
            }
            else
            {
                /* VERIFY   icvlen,SP,P,H */
                *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
            }
        }
        else
        {
            /* DIR CRYPT,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
            /* VERIFY   0,SP,P */
            *tp++=0xd5060000 | ((0u)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 2: /* esp_out_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound CCM\n");
            return TKB_BAD_PACKET;
        }
        /* INS      HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32   salt */
        salt = EVAL_salt();
        *tp++=0x00000000 | ((salt)&0xffffffffu)<<0;
        /* INS      HASHONLY,ORIG_IV1,8 */
        *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,6     ; Insert message length + AAD length. */
        *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
        /* DATA32 swaplen                     ; Message length, byte-swapped */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* DATA32   0x0800  ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((2048u)&0xffffffffu)<<0;
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 6 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((6u)&0x1ffu)<<0;
        }
        else
        {
            /* DATA32   0x0c00 ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((3072u)&0xffffffffu)<<0;
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4 */
            *tp++=0x23980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 2 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((2u)&0x1ffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+16, 16 */
        *tp++=0xa0000000 | ((16u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        hashpad = EVAL_hashpad();
        if (hashpad == 0u)
        {
            /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        }
        else
        {
            /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2f200000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            /* INS      HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((hashpad)&0x1ffu)<<0;
        }
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 3: /* esp_in_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound CCM\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound CCM\n");
            return TKB_BAD_PACKET;
        }
        /* RETR     NONE,ORIG_SPI,8 */
        *tp++=0x40900000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32   salt */
        salt = EVAL_salt();
        *tp++=0x00000000 | ((salt)&0xffffffffu)<<0;
        /* RETR     HASHONLY,ORIG_IV1,8 */
        *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,6    ; Insert message length + AAD length. */
        *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
        /* DATA32 swaplen                    ; Message length, byte-swapped */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* DATA32 0x0800  ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((2048u)&0xffffffffu)<<0;
            /* INS      HASHONLY,ORIG_SPI,8 */
            *tp++=0x22900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 6 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((6u)&0x1ffu)<<0;
        }
        else
        {
            /* DATA32 0x0c00 ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((3072u)&0xffffffffu)<<0;
            /* INS      HASHONLY,ORIG_SPI,4 */
            *tp++=0x22900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES, 4 */
            *tp++=0x22980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 2 */
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((2u)&0x1ffu)<<0;
        }
        /* REMRES   bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        hashpad = EVAL_hashpad();
        if (hashpad == 0u)
        {
            /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST */
            *tp++=0x0f000000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
            /* INS      HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((hashpad)&0x1ffu)<<0;
        }
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* VERIFY   icvlen,S,SP,P,H */
            *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
            if (extseq > 0u)
            {
                /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
            }
            else
            {
                /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
            }
        }
        else
        {
            /* VERIFY   icvlen,SP,P,H */
            *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 4: /* esp_out_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound GCM\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8,LAST */
            *tp++=0x2b900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4, LAST */
            *tp++=0x2b980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+16, 16 */
        *tp++=0xa0000000 | ((16u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 5: /* esp_in_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound GCM\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound GCM\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8,LAST */
            *tp++=0x4a900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4,LAST */
            *tp++=0x2a980000 | ((4u)&0x1ffffu)<<0;
        }
        /* RETR     NONE,ORIG_IV1,ivlen */
        *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
        *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* VERIFY   icvlen,S,SP,P,H */
            *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
            if (extseq > 0u)
            {
                /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
            }
            else
            {
                /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
            }
        }
        else
        {
            /* VERIFY   icvlen,SP,P,H */
            *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 6: /* esp_out_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound GMAC\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4 */
            *tp++=0x23980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      HASH,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x23a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+16, 16 */
        *tp++=0xa0000000 | ((16u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      HASH, packetsize-bypass */
        *tp++=0x03000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        /* INS      HASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2b220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 7: /* esp_in_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound GMAC\n");
            return TKB_BAD_PACKET;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound GMAC\n");
            return TKB_BAD_PACKET;
        }
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8 */
            *tp++=0x42900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4 */
            *tp++=0x22980000 | ((4u)&0x1ffffu)<<0;
        }
        /* RETR     HASHONLY,ORIG_IV1,ivlen */
        *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      HASH,packetsize - ivlen - 8 - icvlen - bypass,LAST,LASTHASH */
        *tp++=0x0b020000 | ((-8u+packetsize-ivlen-icvlen-bypass)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* VERIFY   icvlen,S,SP,P,H */
            *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
            if (extseq > 0u)
            {
                /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
            }
            else
            {
                /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
            }
        }
        else
        {
            /* VERIFY   icvlen, SP,P,H */
            *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 8: /* ssltls_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound\n");
            return TKB_BAD_PACKET;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
            *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,ORIG_SPI,2           ; For SSL, do not hash version field. */
            *tp++=0x21900000 | ((2u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2 */
        *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV0,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a00000 | ((ivlen)&0x1ffffu)<<0;
        if (packetsize != bypass)
        {
            /* DIR CRYPTHASH, packetsize-bypass,LASTHASH */
            *tp++=0x07020000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0, LASTHASH */
            *tp++=0x27020000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            /* INS CRYPT,ORIG_HASH,icvlen,LAST,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x2de60000 | ((icvlen)&0x1ffffu)<<0;
            /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
            *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 1: /* upd_arc4 */
            /* INS CRYPT,ORIG_HASH,icvlen,LAST,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x2de60000 | ((icvlen)&0x1ffffu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
            *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay != 0u)
            {
                /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS CRYPT,PAD_SSL,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d360000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,2,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay != 0u)
            {
                /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS CRYPT,PAD_SSL,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d360000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,4,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        case 4: /* upd_blk */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
            *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 9: /* ssltls_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, payload size for SSLTLS inbound\n");
            return TKB_BAD_PACKET;
        }
#if TKB_SINGLE_PASS_SSLTLS == 1u
        upd_handling = EVAL_upd_handling();
        if (upd_handling <= 1u)
        {
            if (bypass > 0u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                /* REM 4  ; Remove DTLS/CAPWAP header. */
                *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* DIR HASHONLY,3       ; Hash type and version number */
                    *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,1       ; Hash type only for SSL */
                    *tp++=0x02000000 | ((1u)&0x1ffffu)<<0;
                    /* REM 2 */
                    *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,ORIG_TOKEN,2 */
            *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
            /* DATA32 swaplen */
            swaplen = EVAL_swaplen();
            *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
            /* REM 2                              ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* REMRES bypass+paylen,icvlen          ; Cause the MAC to be removed */
            icvlen = EVAL_icvlen();
            *tp++=0xa0000000 | ((bypass+paylen)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
            /* DIR CRYPTHASH,paylen,LASTHASH */
            *tp++=0x07020000 | ((paylen)&0x1ffffu)<<0;
            switch(upd_handling)
            {
            case 0: /* upd_null */
                /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
                *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
                if (extseq == 0u)
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,2,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                }
                else if (extseq == 1u)
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,S,H */
                    *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
                }
                break;
            case 1: /* upd_arc4 */
                /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
                *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
                /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
                *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
                break;
            }
        }
        else
        {
            /* REMRES 0,4,NOUPDCHK */
            *tp++=0xa0020000 | ((0u)&0xffffu)<<0 | ((4u)&0x3fu)<<19;
            cipher_is_aes = EVAL_cipher_is_aes();
            if (cipher_is_aes == 0u)
            {
                /* INS CRYPTONLY,ORIG_TOKEN,12 */
                *tp++=0x24d80000 | ((12u)&0x1ffffu)<<0;
                ssltls_lastblock = EVAL_ssltls_lastblock();
                TokenBuilder_CopyBytes(tp, ssltls_lastblock, 12);
                tp += 3;
                /* INS CRYPT,ORIG_TOKEN,4 */
                *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
                ssltls_lastword = EVAL_ssltls_lastword();
                TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
                tp += 1;
            }
            else
            {
                /* INS CRYPTONLY,ORIG_TOKEN,28 */
                *tp++=0x24d80000 | ((28u)&0x1ffffu)<<0;
                ssltls_lastblock = EVAL_ssltls_lastblock();
                TokenBuilder_CopyBytes(tp, ssltls_lastblock, 28);
                tp += 7;
                /* INS CRYPT,ORIG_TOKEN,4 */
                *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
                ssltls_lastword = EVAL_ssltls_lastword();
                TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
                tp += 1;
            }
            /* DIR NONE,0,LAST */
            *tp++=0x08000000 | ((0u)&0x1ffffu)<<0;
            if (bypass > 0u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
            hstatelen = EVAL_hstatelen();
            if (hstatelen != 0u)
            {
                /* REM 4  ; Remove DTLS/CAPWAP header. */
                *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            }
            else
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* INS HASHONLY,ORIG_SPI_RES,3       ; Hash type and version number */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_SPI_RES,1       ; Hash type only. */
                    *tp++=0x22c00000 | ((1u)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,ORIG_LENCOR,paylen-1 */
            *tp++=0x22780000 | ((-1u+paylen)&0x1ffffu)<<0;
            /* REM 2                              ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            ivlen = EVAL_ivlen();
            if (ivlen > 0u)
            {
                /* RETR NONE,ORIG_IV0,ivlen */
                *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            }
            /* REMRES bypass,icvlen,NOUPDCHK          ; Cause the MAC to be removed */
            icvlen = EVAL_icvlen();
            *tp++=0xa0020000 | ((bypass)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
            /* DIRX CRYPTHASH,ORIG_LENCOR,0,LASTHASH */
            *tp++=0x077a0000 | ((0u)&0x1ffffu)<<0;
            /* DIRX CRYPT,ORIG_LENCOR,icvlen+1,LAST,LASTHASHPKT */
            *tp++=0x0d7e0000 | ((1u+icvlen)&0x1ffffu)<<0;
            switch(upd_handling)
            {
            case 2: /* upd_iv2 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_IV0,iv_offset,2,P */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                break;
            case 3: /* upd_iv4 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_IV0,iv_offset,4,P */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
                break;
            case 4: /* upd_blk */
                if (extseq == 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,2,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                }
                else if (extseq == 1u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,P,S,H */
                    *tp++=0xd9070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
                }
                break;
            }
        }
#else
        if (bypass > 0u)
        {
            /* DIR OUT,bypass */
            *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* REM 4  ; Remove DTLS/CAPWAP header. */
            *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
            *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
            *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
            *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SEQNUM,4 */
            *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* DIR HASHONLY,3       ; Hash type and version number */
                *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,1       ; Hash type only for SSL */
                *tp++=0x02000000 | ((1u)&0x1ffffu)<<0;
                /* REM 2 */
                *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            }
        }
        /* INS HASHONLY,ORIG_TOKEN,2 */
        *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* REM 2                              ; Remove fragment length. */
        *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
        ivlen = EVAL_ivlen();
        if (ivlen > 0u)
        {
            /* RETR NONE,ORIG_IV0,ivlen */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
        }
        /* REMRES bypass+paylen,icvlen          ; Cause the MAC to be removed */
        icvlen = EVAL_icvlen();
        *tp++=0xa0000000 | ((bypass+paylen)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
        /* DIR CRYPTHASH,paylen,LASTHASH */
        *tp++=0x07020000 | ((paylen)&0x1ffffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
            if (extseq == 0u)
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            }
            else if (extseq == 1u)
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,S,H */
                *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
            }
            break;
        case 1: /* upd_arc4 */
            /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
            *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* DIR CRYPT,icvlen+pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0d060000 | ((icvlen+pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* DIR CRYPT,icvlen,LASTHASH */
                *tp++=0x05020000 | ((icvlen)&0x1ffffu)<<0;
                /* DIR CRYPTONLY,pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0c060000 | ((pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,2,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            antireplay = EVAL_antireplay();
            if (antireplay != 0u)
            {
                /* DIR CRYPT,icvlen+pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0d060000 | ((icvlen+pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* DIR CRYPT,icvlen,LASTHASH */
                *tp++=0x05020000 | ((icvlen)&0x1ffffu)<<0;
                /* DIR CRYPTONLY,pad_bytes_in,LAST,LASTHASHPKT */
                pad_bytes_in = EVAL_pad_bytes_in();
                *tp++=0x0c060000 | ((pad_bytes_in)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,4,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        case 4: /* upd_blk */
            /* DIR CRYPT,icvlen+pad_bytes_in,LAST,LASTHASHPKT */
            pad_bytes_in = EVAL_pad_bytes_in();
            *tp++=0x0d060000 | ((icvlen+pad_bytes_in)&0x1ffffu)<<0;
            if (extseq == 0u)
            {
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            }
            else if (extseq == 1u)
            {
                /* VERIFY icvlen,P,H */
                *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,P,S,H */
                *tp++=0xd9070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
            }
            break;
        }
#endif
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 21: /* ssltls_gcm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound GCM\n");
            return TKB_BAD_PACKET;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 ; Output sequence number for DTLS */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2,LAST */
        *tp++=0x2ad80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        if (extseq != 0u)
        {
            if (hstatelen != 0u)
            {
                /* REMRES bypass + 4 + 5 + 8 + 8, 16 */
                *tp++=0xa0000000 | ((25u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            }
            else
            {
                /* REMRES bypass + 5 + 8 + 8, 16 */
                *tp++=0xa0000000 | ((21u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            }
        }
        else
        {
            /* REMRES bypass + 5 + 8, 16 */
            *tp++=0xa0000000 | ((13u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        if (packetsize != bypass)
        {
            /* DIR CRYPTHASH, packetsize-bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0, LAST, LASTHASH */
            *tp++=0x2f020000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 22: /* ssltls_gcm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound GCM\n");
            return TKB_BAD_PACKET;
        }
        hstatelen = EVAL_hstatelen();
        if (hstatelen != 0u)
        {
            /* REM 4  ; Remove DTLS/CAPWAP header. */
            *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
            *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
            *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
            *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SEQNUM,4 */
            *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
            /* DIR HASHONLY,3       ; Hash type and version number */
            *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2,LAST */
        *tp++=0x2ad80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* REM 2                              ; Remove fragment length. */
        *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR CRYPTHASH, paylen,LAST,LASTHASH */
        *tp++=0x0f020000 | ((paylen)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        if (extseq == 0u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
        }
        else if (extseq == 1u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        }
        else
        {
            /* VERIFY icvlen,S,H */
            *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 10: /* basic_crypto */
#if TKB_HAVE_PROTO_BASIC == 1u
        ivlen = EVAL_ivlen();
        if (packetsize < ivlen+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypto\n");
            return TKB_BAD_PACKET;
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 1: /* iv_inbound_cbc */
            /* RETR NONE,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 2: /* iv_outbound_ctr */
            /* INS  OUT,ORIG_IV1,8 */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  OUT,ORIG_IV0,8 */
            *tp++=0x21a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPT,packetsize-ivlen-bypass */
        *tp++=0x05000000 | ((packetsize-ivlen-bypass)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASHPKT */
        pad_bytes_basic = EVAL_pad_bytes_basic();
        *tp++=0x2d060000 | ((0u)&0xffu)<<9 | ((pad_bytes_basic)&0x1ffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            /* CTX ORIG_CHKSUM,iv_offset,1,P,F ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce3800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P,F   ; Update ARC4 state. */
            *tp++=0xe0d63800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* CTX ORIG_IV0,iv_offset,2,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 11: /* basic_hash */
#if TKB_HAVE_PROTO_BASIC == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
            if (hstatelen > 16u)
            {
                /* CTX ORIG_SPI_RES,seq_offset+hstatelen-16,1,P,F ; Update block counter */
                *tp++=0xe0c63800 | ((-16u+seq_offset+hstatelen)&0xffu)<<0 | ((1u)&0xfu)<<24;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 14: /* basic_crypthash */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypthash\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 1: /* iv_inbound_cbc */
            /* RETR HASHONLY,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x42a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 2: /* iv_outbound_ctr */
            /* INS  HASH,ORIG_IV1,8 */
            *tp++=0x23a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR HASH,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x43a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  HASH,ORIG_IV0,8 */
            *tp++=0x23a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  HASH,ORIG_IV0,16 */
            *tp++=0x23a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        pad_bytes_basic = EVAL_pad_bytes_basic();
        if (pad_bytes_basic > 0u)
        {
            /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt-antireplay */
            *tp++=0x07000000 | ((packetsize-ivlen-bypass-aadlen_pkt-antireplay)&0x1ffffu)<<0;
            /* INS CRYPTHASH,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASH */
            *tp++=0x2f020000 | ((0u)&0xffu)<<9 | ((pad_bytes_basic)&0x1ffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt-antireplay,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-ivlen-bypass-aadlen_pkt-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
            if (hstatelen > 16u)
            {
                /* CTX ORIG_SPI_RES,seq_offset+hstatelen-16,1,P,F ; Update block counter */
                *tp++=0xe0c63800 | ((-16u+seq_offset+hstatelen)&0xffu)<<0 | ((1u)&0xfu)<<24;
            }
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            /* CTX ORIG_CHKSUM,iv_offset,1,P,F ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce3800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P,F   ; Update ARC4 state. */
            *tp++=0xe0d63800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* CTX ORIG_IV0,iv_offset,2,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 15: /* basic_out_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out ccm\n");
            return TKB_BAD_PACKET;
        }
        /* INS HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32 basic_salt */
        basic_salt = EVAL_basic_salt();
        *tp++=0x00000000 | ((basic_salt)&0xffffffffu)<<0;
        if (ivhandling == 5u)
        {
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASH, ORIG_IV1,8 */
            *tp++=0x23a80000 | ((8u)&0x1ffffu)<<0;
        }
        aadlen_swap = EVAL_aadlen_swap();
        if (aadlen_swap > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,6 */
            *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
            /* DATA32 aadlen_swap */
            *tp++=0x00000000 | ((aadlen_swap)&0xffffffffu)<<0;
            aadlen_tkn = EVAL_aadlen_tkn();
            if (aadlen_tkn > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                aad = EVAL_aad();
                if (aadlen_tkn > 64)
                {
                    LOG_CRIT("Field too large\n");
                    return TKB_BAD_FIELD_SIZE;
                }
                TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
                tp += (aadlen_tkn + 3)/4;
            }
            else if (aadlen_pkt > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* DIR HASH,aadlen_pkt */
                    *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,aadlen_pkt */
                    *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,PAD_ZERO,0,aadpad */
            aadpad = EVAL_aadpad();
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((aadpad)&0x1ffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_TOKEN,4 */
            *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
        }
        /* REMRES bypass+8+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT,PAD_ZERO,0,16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        basic_hashpad = EVAL_basic_hashpad();
        if (basic_hashpad == 0u)
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST */
            *tp++=0x0f000000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
            /* INS HASHONLY,PAD_ZERO,0,basic_hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((basic_hashpad)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 16: /* basic_in_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in ccm\n");
            return TKB_BAD_PACKET;
        }
        /* INS HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32 basic_salt */
        basic_salt = EVAL_basic_salt();
        *tp++=0x00000000 | ((basic_salt)&0xffffffffu)<<0;
        if (ivhandling == 0u)
        {
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_IV1,8 */
            *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        }
        aadlen_swap = EVAL_aadlen_swap();
        if (aadlen_swap > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,6 */
            *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
            /* DATA32 aadlen_swap */
            *tp++=0x00000000 | ((aadlen_swap)&0xffffffffu)<<0;
            aadlen_tkn = EVAL_aadlen_tkn();
            if (aadlen_tkn > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                aad = EVAL_aad();
                if (aadlen_tkn > 64)
                {
                    LOG_CRIT("Field too large\n");
                    return TKB_BAD_FIELD_SIZE;
                }
                TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
                tp += (aadlen_tkn + 3)/4;
            }
            else if (aadlen_pkt > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* DIR HASH,aadlen_pkt */
                    *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,aadlen_pkt */
                    *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,PAD_ZERO,0,aadpad */
            aadpad = EVAL_aadpad();
            *tp++=0x22000000 | ((0u)&0xffu)<<9 | ((aadpad)&0x1ffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_TOKEN,4 */
            *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
        }
        /* REMRES bypass+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT,PAD_ZERO,0,16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        basic_hashpad = EVAL_basic_hashpad();
        if (basic_hashpad == 0u)
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST */
            icvlen = EVAL_icvlen();
            *tp++=0x0f000000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
            /* INS HASHONLY,PAD_ZERO,0,basic_hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0xffu)<<9 | ((basic_hashpad)&0x1ffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 17: /* basic_out_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out gcm\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                return TKB_BAD_PACKET;
            }
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                return TKB_BAD_PACKET;
            }
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
        *tp++=0x0f020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 18: /* basic_in_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in gcm\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                return TKB_BAD_PACKET;
            }
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                return TKB_BAD_PACKET;
            }
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        /* DIR      CRYPTHASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x0f020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 19: /* basic_out_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out gmac\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv. */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16,LAST */
        *tp++=0x2d000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 20: /* basic_in_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in gmac\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv Do not authenticate IV */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16,LAST */
        *tp++=0x2d000000 | ((0u)&0xffu)<<9 | ((16u)&0x1ffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 23: /* basic_xts_crypto */
#if TKB_HAVE_CRYPTO_XTS == 1u
        ivlen = EVAL_ivlen();
        if (packetsize < ivlen+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypto\n");
            return TKB_BAD_PACKET;
        }
        swap_j = EVAL_swap_j();
        if (swap_j != 0u)
        {
            /* INSCTX NONE,ORIG_TOKEN,10,16 */
            *tp++=0x90d80000 | ((10u)&0x1fu)<<12 | ((16u)&0x1ffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 swap_j */
            *tp++=0x00000000 | ((swap_j)&0xffffffffu)<<0;
        }
        switch(ivhandling)
        {
        case 1: /* iv_inbound_cbc */
            /* RETR NONE,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPT,packetsize-ivlen-bypass */
        *tp++=0x05000000 | ((packetsize-ivlen-bypass)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASHPKT */
        pad_bytes_basic = EVAL_pad_bytes_basic();
        *tp++=0x2d060000 | ((0u)&0xffu)<<9 | ((pad_bytes_basic)&0x1ffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 24: /* basic_kasumi_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            return TKB_BAD_PACKET;
        }
        /* INS HASHONLY,ORIG_TOKEN,8 */
        *tp++=0x22d80000 | ((8u)&0x1ffffu)<<0;
        /* DATA32 count */
        count = EVAL_count();
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        bearer_dir_fresh = EVAL_bearer_dir_fresh();
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 25: /* basic_snow_hash */
    case 26: /* basic_zuc_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            return TKB_BAD_PACKET;
        }
        /* INSCTX NONE,ORIG_TOKEN,10,16 */
        *tp++=0x90d80000 | ((10u)&0x1fu)<<12 | ((16u)&0x1ffu)<<0;
        /* DATA32 count */
        count = EVAL_count();
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        bearer_dir_fresh = EVAL_bearer_dir_fresh();
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        /* DATA32 count */
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 27: /* basic_hashenc */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypthash\n");
            return TKB_BAD_PACKET;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  OUT,ORIG_IV0,8 */
            *tp++=0x21a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt,LASTHASH */
        *tp++=0x07020000 | ((packetsize-ivlen-bypass-aadlen_pkt)&0x1ffffu)<<0;
        /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_TLS,0,pad_bytes_hashenc,LAST,LASTHASHPKT */
        pad_bytes_hashenc = EVAL_pad_bytes_hashenc();
        *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes_hashenc)&0x1ffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 28: /* basic_dechash */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_pkt+aadlen_tkn < 2u)
        {
            LOG_WARN("TokenBuilder: bad packet, aad too short\n");
            return TKB_BAD_PACKET;
        }
        /* REMRES 0,4,NOUPDCHK */
        *tp++=0xa0020000 | ((0u)&0xffffu)<<0 | ((4u)&0x3fu)<<19;
        cipher_is_aes = EVAL_cipher_is_aes();
        if (cipher_is_aes == 0u)
        {
            ivlen = EVAL_ivlen();
            if (packetsize < 16u+bypass+aadlen_pkt+ivlen)
            {
                LOG_WARN("TokenBuilder: bad packet, too short for basic dechash\n");
                return TKB_BAD_PACKET;
            }
            /* INS CRYPTONLY,ORIG_TOKEN,12 */
            *tp++=0x24d80000 | ((12u)&0x1ffffu)<<0;
            ssltls_lastblock = EVAL_ssltls_lastblock();
            TokenBuilder_CopyBytes(tp, ssltls_lastblock, 12);
            tp += 3;
            /* INS CRYPT,ORIG_TOKEN,4 */
            *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
            ssltls_lastword = EVAL_ssltls_lastword();
            TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
            tp += 1;
        }
        else
        {
            ivlen = EVAL_ivlen();
            if (packetsize < 32u+bypass+aadlen_pkt+ivlen)
            {
                LOG_WARN("TokenBuilder: bad packet, too short for basic dechash\n");
                return TKB_BAD_PACKET;
            }
            /* INS CRYPTONLY,ORIG_TOKEN,28 */
            *tp++=0x24d80000 | ((28u)&0x1ffffu)<<0;
            ssltls_lastblock = EVAL_ssltls_lastblock();
            TokenBuilder_CopyBytes(tp, ssltls_lastblock, 28);
            tp += 7;
            /* INS CRYPT,ORIG_TOKEN,4 */
            *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
            ssltls_lastword = EVAL_ssltls_lastword();
            TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
            tp += 1;
        }
        /* DIR NONE,0,LAST */
        *tp++=0x08000000 | ((0u)&0x1ffffu)<<0;
        if (bypass > 0u)
        {
            /* DIR OUT,bypass */
            *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
        }
        if (aadlen_tkn > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn-2 */
            *tp++=0x22d80000 | ((-2u+aadlen_tkn)&0x1ffffu)<<0;
            aad = EVAL_aad();
            if (-2u+aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, -2u+aadlen_tkn);
            tp += (-2u+aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            /* DIR HASHONLY,aadlen_pkt-2 */
            *tp++=0x02000000 | ((-2u+aadlen_pkt)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_LENCOR,packetsize-bypass-aadlen_pkt-ivlen-icvlen-1 */
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        *tp++=0x22780000 | ((-1u+packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
        /* REM 2 */
        *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
        if (ivlen > 0u)
        {
            /* RETR NONE,ORIG_IV0,ivlen */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
        }
        /* REMRES bypass,icvlen,NOUPDCHK          ; Cause the MAC to be removed */
        *tp++=0xa0020000 | ((bypass)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
        /* DIRX CRYPTHASH,ORIG_LENCOR,0,LASTHASH */
        *tp++=0x077a0000 | ((0u)&0x1ffffu)<<0;
        /* DIRX CRYPT,ORIG_LENCOR,icvlen+1,LAST,LASTHASHPKT */
        *tp++=0x0d7e0000 | ((1u+icvlen)&0x1ffffu)<<0;
        /* VERIFY icvlen,P,H */
        *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 12: /* srtp_out */
#if TKB_HAVE_PROTO_SRTP == 1u
        srtp_offset = EVAL_srtp_offset();
        if (packetsize <= bypass+srtp_offset)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SRTP outbound\n");
            return TKB_BAD_PACKET;
        }
        if (srtp_offset > 0u)
        {
            /* DIR  HASH, srtp_offset */
            *tp++=0x03000000 | ((srtp_offset)&0x1ffffu)<<0;
            /* DIR  CRYPTHASH, packetsize - bypass - srtp_offset,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-srtp_offset)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR  HASH, packetsize - bypass,LAST */
            *tp++=0x0b000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* INS  HASH, ORIG_TOKEN, 4, LASTHASH ; SCTCP, index gets appended */
            *tp++=0x23da0000 | ((4u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS  HASHONLY, ORIG_TOKEN, 4, LASTHASH ; SRTP, ROC gets hashed, not appended */
            *tp++=0x22da0000 | ((4u)&0x1ffffu)<<0;
        }
        /* DATA32 srtp_swaproc */
        srtp_swaproc = EVAL_srtp_swaproc();
        *tp++=0x00000000 | ((srtp_swaproc)&0xffffffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            /* INS OUT,ORIG_SPI,4,LASTHASH */
            *tp++=0x21920000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS OUT, ORIG_HASH, icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    case 13: /* srtp_in */
#if TKB_HAVE_PROTO_SRTP == 1u
        srtp_offset = EVAL_srtp_offset();
        icvlen = EVAL_icvlen();
        extseq = EVAL_extseq();
        antireplay = EVAL_antireplay();
        if (packetsize <= bypass+srtp_offset+icvlen+extseq+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SRTP inbound\n");
            return TKB_BAD_PACKET;
        }
        if (srtp_offset > 0u)
        {
            /* DIR  HASH, srtp_offset */
            *tp++=0x03000000 | ((srtp_offset)&0x1ffffu)<<0;
            /* DIR CRYPTHASH, packetsize - bypass - srtp_offset - icvlen - extseq -antireplay,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-srtp_offset-icvlen-extseq-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASH, packetsize - bypass - icvlen - extseq -antireplay,LAST */
            *tp++=0x0b000000 | ((packetsize-bypass-icvlen-extseq-antireplay)&0x1ffffu)<<0;
        }
        if (extseq > 0u)
        {
            /* DIR  HASHONLY, 4, LASTHASH ; SCTCP extraxt from packet. */
            *tp++=0x02020000 | ((4u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS  HASHONLY, ORIG_TOKEN, 4, LASTHASH ; SRTP, ROC gets hashed, not appended */
            *tp++=0x22da0000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 srtp_swaproc */
            srtp_swaproc = EVAL_srtp_swaproc();
            *tp++=0x00000000 | ((srtp_swaproc)&0xffffffffu)<<0;
        }
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_SPI,4 */
            *tp++=0x40900000 | ((4u)&0x1ffffu)<<0;
        }
        if (icvlen > 0u)
        {
            /* RETR NONE,ORIG_HASH, icvlen,LASTHASHPKT */
            *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay > 0u)
            {
                /* VERIFY icvlen,H,SP */
                *tp++=0xd4070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
        }
        else
        {
            /* INS NONE,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x20060000 | ((0u)&0xffu)<<9 | ((0u)&0x1ffu)<<0;
            if (antireplay > 0u)
            {
                /* VERIFY 0,SP */
                *tp++=0xd4060000 | ((0u)&0x7fu)<<0;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
#endif
        break;
    default:
        LOG_WARN("TokenBuilder: bad protocol\n");
        return TKB_BAD_PROTOCOL;
    }


    *TokenWord32Count_p = tp - (uint32_t*)Token_p;
    return TKB_STATUS_OK;
}

/* end of file token_builder_core.c */
