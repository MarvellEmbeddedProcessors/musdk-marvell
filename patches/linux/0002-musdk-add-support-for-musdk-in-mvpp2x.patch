From b90d1e1803b4d5c490e627c7cd99dba5f3560e36 Mon Sep 17 00:00:00 2001
From: Lior Amsalem <alior@marvell.com>
Date: Mon, 19 Dec 2016 11:26:56 +0200
Subject: [PATCH 2/8] musdk: add support for musdk in mvpp2x

Change-Id: Ia83f20b04fd5763e738a484e4edb0bab673aba38
Signed-off-by: Yuval Caduri <cyuval@marvell.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |   1 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c  |  36 ++++++
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |   4 +-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c | 124 +++++++++++++++++----
 4 files changed, 145 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index 57aaca2..9fc7ebe 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -796,6 +796,7 @@ int mv_pp2x_setup_rxqs(struct mv_pp2x_port *port);
 int mv_pp2x_setup_txqs(struct mv_pp2x_port *port);
 void mv_pp2x_cleanup_txqs(struct mv_pp2x_port *port);
 void mv_pp2x_set_ethtool_ops(struct net_device *netdev);
+void mv_pp2x_set_non_kernel_ethtool_ops(struct net_device *netdev);
 int mv_pp22_rss_rxfh_indir_set(struct mv_pp2x_port *port);
 int mv_pp2x_cos_classifier_set(struct mv_pp2x_port *port,
 			       enum mv_pp2x_cos_classifier cos_mode);
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
index 05e79d0..4069c06 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
@@ -1238,7 +1238,43 @@ static const struct ethtool_ops mv_pp2x_eth_tool_ops = {
 	.self_test		= mv_pp2x_eth_tool_diag_test,
 };
 
+u32 mv_pp2x_non_kernel_op_get_link(struct net_device *dev)
+{
+	return 1;
+}
+
+static const struct ethtool_ops mv_pp2x_non_kernel_eth_tool_ops = {
+	.get_link		= ethtool_op_get_link,
+	.get_settings		= mv_pp2x_ethtool_get_settings,
+	/*.set_settings		= mv_pp2x_ethtool_set_settings,*/
+	/*.set_coalesce		= mv_pp2x_ethtool_set_coalesce,*/
+	/*.get_coalesce		= mv_pp2x_ethtool_get_coalesce,*/
+	.nway_reset		= mv_pp2x_eth_tool_nway_reset,
+	.get_drvinfo		= mv_pp2x_ethtool_get_drvinfo,
+	.get_ethtool_stats	= mv_pp2x_eth_tool_get_ethtool_stats,
+	.get_sset_count		= mv_pp2x_eth_tool_get_sset_count,
+	.get_strings		= mv_pp2x_eth_tool_get_strings,
+	/*.get_ringparam	= mv_pp2x_ethtool_get_ringparam,*/
+	/*.set_ringparam	= mv_pp2x_ethtool_set_ringparam,*/
+	.get_pauseparam		= mv_pp2x_get_pauseparam,
+	.set_pauseparam		= mv_pp2x_set_pauseparam,
+	.get_rxfh_indir_size	= mv_pp2x_ethtool_get_rxfh_indir_size,
+	.get_rxnfc		= mv_pp2x_ethtool_get_rxnfc,
+	.set_rxnfc		= mv_pp2x_ethtool_set_rxnfc,
+	.get_rxfh		= mv_pp2x_ethtool_get_rxfh,
+	.set_rxfh		= mv_pp2x_ethtool_set_rxfh,
+	.get_regs_len           = mv_pp2x_ethtool_get_regs_len,
+	.get_regs		= mv_pp2x_ethtool_get_regs,
+	.self_test		= mv_pp2x_eth_tool_diag_test,
+};
+
 void mv_pp2x_set_ethtool_ops(struct net_device *netdev)
 {
 	netdev->ethtool_ops = &mv_pp2x_eth_tool_ops;
 }
+
+void mv_pp2x_set_non_kernel_ethtool_ops(struct net_device *netdev)
+{
+	netdev->ethtool_ops = &mv_pp2x_non_kernel_eth_tool_ops;
+}
+
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 2e56db8..ddfc392 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1254,7 +1254,9 @@
 
 /* Port flags */
 #define MVPP2_F_LOOPBACK		BIT(0)
-#define MVPP2_F_IFCAP_NETMAP    BIT(1)
+#define MVPP2_F_IFCAP_NETMAP		BIT(1)
+#define MVPP2_F_IF_MUSDK		BIT(2)
+
 
 /* Marvell tag types */
 enum mv_pp2x_tag_type {
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 959c8ea..92be5a1 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -2858,6 +2858,14 @@ out_no_tx_desc:
 	return 0;
 }
 
+
+
+static int mv_pp2x_dummy_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	pr_debug("mv_pp2x_dummy_tx \n");
+	return NETDEV_TX_OK;
+}
+
 /* Main tx processing */
 static int mv_pp2x_tx(struct sk_buff *skb, struct net_device *dev)
 {
@@ -3594,8 +3602,8 @@ int mv_pp2x_open(struct net_device *dev)
 		netdev_err(port->dev, "cannot allocate Tx queues\n");
 		goto err_cleanup_rxqs;
 	}
-
-	err = mv_pp2x_setup_irqs(dev, port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		err = mv_pp2x_setup_irqs(dev, port);
 	if (err) {
 		netdev_err(port->dev, "cannot allocate irq's\n");
 		goto err_cleanup_txqs;
@@ -3603,14 +3611,15 @@ int mv_pp2x_open(struct net_device *dev)
 	/* In default link is down */
 	netif_carrier_off(port->dev);
 
-	/* Unmask interrupts on all CPUs */
-	on_each_cpu(mv_pp2x_interrupts_unmask, port, 1);
-
-	/* Unmask shared interrupts */
-	mv_pp2x_shared_thread_interrupts_unmask(port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK)) {
+		/* Unmask interrupts on all CPUs */
+		on_each_cpu(mv_pp2x_interrupts_unmask, port, 1);
 
-	/* Port is init in uboot */
+		/* Unmask shared interrupts */
+		mv_pp2x_shared_thread_interrupts_unmask(port);
 
+		/* Port is init in uboot */
+	}
 	if (port->priv->pp2_version == PPV22)
 		mvcpn110_mac_hw_init(port);
 	mv_pp2x_start_dev(port);
@@ -3663,6 +3672,13 @@ int mv_pp2x_stop(struct net_device *dev)
 	return 0;
 }
 
+int mv_pp2x_dummy_stop(struct net_device *dev)
+{
+	netdev_warn(dev, "ndo_stop not supported\n");
+	return 0;
+}
+
+
 static void mv_pp2x_set_rx_promisc(struct mv_pp2x_port *port)
 {
 	struct mv_pp2x_hw *hw = &port->priv->hw;
@@ -3856,6 +3872,14 @@ error:
 	return err;
 }
 
+
+static int mv_pp2x_dummy_change_mtu(struct net_device *dev, int mtu)
+{
+	netdev_warn(dev, "ndo_change_mtu not supported\n");
+	return 0;
+
+}
+
 static struct rtnl_link_stats64 *
 mv_pp2x_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
 {
@@ -3980,6 +4004,20 @@ static const struct net_device_ops mv_pp2x_netdev_ops = {
 	.ndo_set_features	= mv_pp2x_netdev_set_features,
 };
 
+static const struct net_device_ops mv_pp2x_non_kernel_netdev_ops = {
+	.ndo_open		= mv_pp2x_open,
+	.ndo_stop		= mv_pp2x_dummy_stop,
+	.ndo_start_xmit		= mv_pp2x_dummy_tx,
+	/*.ndo_select_queue	= mv_pp2x_select_queue,*/
+	.ndo_set_rx_mode	= mv_pp2x_set_rx_mode,
+	.ndo_set_mac_address	= mv_pp2x_set_mac_address,
+	.ndo_change_mtu		= mv_pp2x_dummy_change_mtu,
+	.ndo_get_stats64	= mv_pp2x_get_stats64,
+	.ndo_do_ioctl		= mv_pp2x_ioctl,
+	.ndo_set_features	= mv_pp2x_netdev_set_features,
+};
+
+
 /* Driver initialization */
 
 static void mv_pp21_port_power_up(struct mv_pp2x_port *port)
@@ -4366,7 +4404,9 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 		goto err_free_percpu;
 
 	/* Configure queue_vectors */
-	priv->pp2xdata->mv_pp2x_port_queue_vectors_init(port);
+
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		priv->pp2xdata->mv_pp2x_port_queue_vectors_init(port);
 
 	/* Configure Rx queue group interrupt for this port */
 	priv->pp2xdata->mv_pp2x_port_isr_rx_group_cfg(port);
@@ -4393,7 +4433,8 @@ static int mv_pp2x_port_init(struct mv_pp2x_port *port)
 	port->pkt_size = MVPP2_RX_PKT_SIZE(port->dev->mtu);
 
 	/* Initialize pools for swf */
-	err = mv_pp2x_swf_bm_pool_init(port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		err = mv_pp2x_swf_bm_pool_init(port);
 	if (err)
 		goto err_free_percpu;
 	return 0;
@@ -4444,6 +4485,8 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	int port_num_irq;
 	int phy_mode;
 	struct phy *comphy;
+	const char *status;
+	int statlen;
 
 	dev = alloc_etherdev_mqs(sizeof(struct mv_pp2x_port),
 				 mv_pp2x_txq_number * num_active_cpus(), mv_pp2x_rxq_number);
@@ -4456,6 +4499,11 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	SET_NETDEV_DEV(dev, &pdev->dev);
 	port->priv = priv;
 
+	status = of_get_property(port_node, "status", &statlen);
+
+	if (statlen > 0 && !strcmp(status, "non-kernel"))
+		port->flags |= MVPP2_F_IF_MUSDK;
+
 	mv_pp2x_port_init_config(port);
 
 	if (of_property_read_u32(port_node, "port-id", &id)) {
@@ -4528,7 +4576,9 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 
 	/* Tx/Rx Interrupt */
 	port_num_irq = mv_pp2x_of_irq_count(port_node);
-	if (port_num_irq != priv->pp2xdata->num_port_irq) {
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		port_num_irq = 0;
+	if ((!(port->flags & MVPP2_F_IF_MUSDK)) && port_num_irq != priv->pp2xdata->num_port_irq) {
 		dev_err(&pdev->dev,
 			"port(%d)-number of irq's doesn't match hw\n", id);
 		goto err_free_netdev;
@@ -4557,8 +4607,16 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	dev->tx_queue_len = tx_queue_size;
 	dev->watchdog_timeo = 5 * HZ;
 	dev->netdev_ops = &mv_pp2x_netdev_ops;
+
 	mv_pp2x_set_ethtool_ops(dev);
 
+	if (port->flags & MVPP2_F_IF_MUSDK) {
+		port->num_tx_queues = 0;
+		port->num_rx_queues = 0;
+		dev->netdev_ops = &mv_pp2x_non_kernel_netdev_ops;
+		mv_pp2x_set_non_kernel_ethtool_ops(dev);
+	}
+
 	if (priv->pp2_version == PPV21)
 		port->first_rxq = (port->id) * mv_pp2x_rxq_number +
 			first_log_rxq_queue;
@@ -4607,7 +4665,7 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		err = -ENOMEM;
 		goto err_free_txq_pcpu;
 	}
-	if (!port->priv->pp2xdata->interrupt_tx_done) {
+	if ((!(port->flags & MVPP2_F_IF_MUSDK)) && port->priv->pp2xdata->interrupt_tx_done == false) {
 		for_each_online_cpu(cpu) {
 			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
 
@@ -4620,6 +4678,8 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 				     mv_pp2x_tx_proc_cb, (unsigned long)dev);
 		}
 	}
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		goto skip_tso_buffers;
 	/* Init pool of external buffers for TSO, fragmentation, etc */
 	for_each_online_cpu(cpu) {
 		port_pcpu = per_cpu_ptr(port->pcpu, cpu);
@@ -4647,7 +4707,7 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 			port_pcpu->ext_buf_pool->buf_pool_in_use++;
 		}
 	}
-
+skip_tso_buffers:
 	features = NETIF_F_SG;
 	dev->features = features | NETIF_F_RXCSUM | NETIF_F_IP_CSUM |
 			NETIF_F_IPV6_CSUM | NETIF_F_TSO;
@@ -4676,8 +4736,10 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	/* Clear MIB counters statistic */
 	mv_gop110_mib_counters_clear(&port->priv->hw.gop, port->mac_data.gop_index);
 
-	mv_pp2x_port_irq_names_update(port);
+	if (!(port->flags & MVPP2_F_IF_MUSDK))
+		mv_pp2x_port_irq_names_update(port);
 
+	netdev_info(dev, "Status: %s\n", status);
 	netdev_info(dev, "Using %s mac address %pM\n", mac_from, dev->dev_addr);
 
 	priv->port_list[priv->num_ports] = port;
@@ -4978,6 +5040,20 @@ static void mv_pp22_init_rxfhindir(struct mv_pp2x *pp2)
 		pp2->rx_indir_table[i] = i % online_cpus;
 }
 
+static inline bool mv_pp2x_port_is_available (struct device_node *port_node)
+{
+	if (of_device_is_available(port_node))
+		return true;
+	else {
+		const char *status;
+		int statlen;
+		status = of_get_property(port_node, "status", &statlen);
+		if (statlen > 0 && !strcmp(status, "non-kernel"))
+			return true;
+	}
+	return false;
+}
+
 static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 				     struct mv_pp2x *priv,	u32 *cell_index, int *port_count)
 {
@@ -4986,9 +5062,11 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 	static bool cell_index_dts_flag;
 	const struct of_device_id *match;
 	struct device_node *dn = pdev->dev.of_node;
+	struct device_node *port_node;
 	struct resource *res;
 	resource_size_t mspg_base, mspg_end;
 	u32	err;
+	int avail_ports_cnt = 0;
 
 	match = of_match_node(mv_pp2x_match_tbl, dn);
 	if (!match)
@@ -5159,7 +5237,13 @@ static int mv_pp2x_platform_data_get(struct platform_device *pdev,
 	/* Get system's tclk rate */
 	hw->tclk = clk_get_rate(hw->pp_clk);
 
-	*port_count = of_get_available_child_count(dn);
+	for_each_child_of_node(dn, port_node) {
+		if (mv_pp2x_port_is_available(port_node))	 {
+			avail_ports_cnt++;
+		}
+	}
+	*port_count = avail_ports_cnt;
+
 	if (*port_count == 0) {
 		dev_err(&pdev->dev, "no ports enabled\n");
 		return -ENODEV;
@@ -5350,10 +5434,12 @@ static int mv_pp2x_probe(struct platform_device *pdev)
 		mv_pp22_init_rxfhindir(priv);
 
 	/* Initialize ports */
-	for_each_available_child_of_node(dn, port_node) {
-		err = mv_pp2x_port_probe(pdev, port_node, priv);
-		if (err < 0)
-			goto err_clk;
+	for_each_child_of_node(dn, port_node) {
+		if (mv_pp2x_port_is_available(port_node)) {
+			err = mv_pp2x_port_probe(pdev, port_node, priv);
+			if (err < 0)
+				goto err_clk;
+		}
 	}
 
 	if (priv->pp2_version == PPV22) {
-- 
1.9.1

