From f2128d43f445a03ace14cca2cf42d6620b20bd69 Mon Sep 17 00:00:00 2001
From: Alan Winkowski <walan@marvell.com>
Date: Sun, 22 Jan 2017 16:36:56 +0200
Subject: [PATCH 6/8] musdk: add support for vlan filtering in parser

Change-Id: Ib4332f4db30d114019c74fc6f27314a1ac605821
Signed-off-by: Alan Winkowski <walan@marvell.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c   | 250 ++++++++++++++++++++-
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h   |   3 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |  44 ++--
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c |  23 ++
 4 files changed, 296 insertions(+), 24 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
index 40cf784..00c7b36 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.c
@@ -636,6 +636,13 @@ static void mv_pp2x_prs_match_etype(struct mv_pp2x_prs_entry *pe, int offset,
 	mv_pp2x_prs_tcam_data_byte_set(pe, offset + 1, ethertype & 0xff, 0xff);
 }
 
+/* Set vid in tcam sw entry */
+static void mv_pp2x_prs_match_vid(struct mv_pp2x_prs_entry *pe, int offset, unsigned short vid)
+{
+	mv_pp2x_prs_tcam_data_byte_set(pe, offset + 0, ((vid & 0xf00) >> 8), 0xf);
+	mv_pp2x_prs_tcam_data_byte_set(pe, offset + 1, vid & 0xff, 0xff);
+}
+
 /* Set bits in sram sw entry */
 static void mv_pp2x_prs_sram_bits_set(struct mv_pp2x_prs_entry *pe, int bit_num,
 				      int val)
@@ -1231,10 +1238,10 @@ static int mv_pp2x_prs_vlan_add(struct mv_pp2x_hw *hw, unsigned short tpid,
 
 		mv_pp2x_prs_match_etype(pe, 0, tpid);
 
-		mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
-		/* Shift 4 bytes - skip 1 vlan tag */
-		mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN,
-					   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+		mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_VID);
+
+		/* Do not shift now, will be shifted after VID is checked*/
+
 		/* Clear all ai bits for next iteration */
 		mv_pp2x_prs_sram_ai_update(pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 
@@ -2028,7 +2035,12 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VLAN);
 	pe.index = MVPP2_PE_VLAN_DBL;
 
-	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_L2);
+	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_VID);
+
+	/* Go back 4 bytes for inner VID checking */
+	mv_pp2x_prs_sram_shift_set(&pe, (-1) * MVPP2_VLAN_TAG_LEN,
+				   MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
 	/* Clear ai for next iterations */
 	mv_pp2x_prs_sram_ai_update(&pe, 0, MVPP2_PRS_SRAM_AI_MASK);
 	mv_pp2x_prs_sram_ri_update(&pe, MVPP2_PRS_RI_VLAN_DOUBLE,
@@ -2062,6 +2074,29 @@ static int mv_pp2x_prs_vlan_init(struct platform_device *pdev,
 	return 0;
 }
 
+static void mv_pp2x_prs_vid_init(struct mv_pp2x_hw *hw)
+{
+	struct mv_pp2x_prs_entry pe;
+
+	memset(&pe, 0, sizeof(struct mv_pp2x_prs_entry));
+
+	/* Set default vid  entry */
+	pe.index = MVPP2_PE_VID_FLTR_DEFAULT;
+	mv_pp2x_prs_tcam_lu_set(&pe, MVPP2_PRS_LU_VID);
+
+	/* Skip VLAN header - Set offset to 4 bytes */
+	mv_pp2x_prs_sram_shift_set(&pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	mv_pp2x_prs_sram_next_lu_set(&pe, MVPP2_PRS_LU_L2);
+
+	/* Unmask all ports */
+	mv_pp2x_prs_tcam_port_map_set(&pe, MVPP2_PRS_PORT_MASK);
+
+	/* Update shadow table and hw entry */
+	mv_pp2x_prs_shadow_set(hw, pe.index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, &pe);
+}
+
 /* Set entries for PPPoE ethertype */
 static int mv_pp2x_prs_pppoe_init(struct mv_pp2x_hw *hw)
 {
@@ -2656,6 +2691,208 @@ void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
 	}
 }
 
+static int mv_pp2x_prs_vid_drop_entry_accept(struct net_device *dev, unsigned int tid, bool add)
+{
+	struct mv_pp2x_prs_entry *pe;
+	unsigned int pmap;
+	struct mv_pp2x_port *port = netdev_priv(dev);
+	struct mv_pp2x_hw *hw = &port->priv->hw;
+
+	pe = kzalloc(sizeof(*pe), GFP_KERNEL);
+	if (!pe)
+		return -1;
+	pe->index = tid;
+
+	if (add) {
+		if (hw->prs_shadow[tid].valid) {
+			pr_info("Default vid drop entry already in place\n");
+			return 0;
+		}
+		mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_VID);
+
+		/* Mask all ports */
+		mv_pp2x_prs_tcam_port_map_set(pe, 0);
+	} else {
+		mv_pp2x_prs_hw_read(hw, pe);
+	}
+
+	/* Update port mask */
+	mv_pp2x_prs_tcam_port_set(pe, port->id, add);
+
+	/* Invalidate the entry if no ports are left enabled */
+	pmap = mv_pp2x_prs_tcam_port_map_get(pe);
+	if (pmap == 0) {
+		if (add) {
+			kfree(pe);
+			return -1;
+		}
+		mv_pp2x_prs_hw_inv(hw, pe->index);
+		hw->prs_shadow[pe->index].valid = false;
+		/*pr_info("removed default vid\n");*/
+		kfree(pe);
+		return 0;
+	}
+
+	/* Continue - set next lookup */
+	mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
+
+	mv_pp2x_prs_sram_ri_update(pe, MVPP2_PRS_RI_DROP_MASK, MVPP2_PRS_RI_DROP_MASK);
+
+	/* Skip VLAN header - Set offset to 4 bytes */
+	mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Update shadow table */
+	mv_pp2x_prs_shadow_set(hw, pe->index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, pe);
+	/*pr_info("added default vid\n");*/
+	kfree(pe);
+	return 0;
+}
+
+/* Return first free tcam index, seeking from start to end */
+static bool mv_pp2x_prs_tcam_vid_empty(struct mv_pp2x_hw *hw, unsigned char start, unsigned char end)
+{
+	int tid;
+
+	if (start > end)
+		swap(start, end);
+
+	for (tid = start; tid <= end; tid++) {
+		if (hw->prs_shadow[tid].valid)
+			return false;
+	}
+	return true;
+}
+
+/* Find tcam entry with matched pair <vid,port> */
+static struct mv_pp2x_prs_entry *
+mv_pp2x_prs_vid_range_find(struct mv_pp2x_hw *hw, int pmap, u16 vid, u16 mask)
+{
+	struct mv_pp2x_prs_entry *pe;
+	unsigned char byte[2], enable[2];
+	u16 rvid, rmask;
+	int tid;
+
+	pe = kzalloc(sizeof(*pe), GFP_KERNEL);
+	if (!pe)
+		return NULL;
+	mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_VID);
+
+	/* Go through the all entires with MVPP2_PRS_LU_VID */
+	for (tid = MVPP2_PE_VID_FILT_RANGE_START;
+	     tid <= MVPP2_PE_VID_FILT_RANGE_END; tid++) {
+		if (!hw->prs_shadow[tid].valid ||
+		    (hw->prs_shadow[tid].lu != MVPP2_PRS_LU_VID))
+			continue;
+
+		pe->index = tid;
+		mv_pp2x_prs_hw_read(hw, pe);
+		mv_pp2x_prs_tcam_data_byte_get(pe, 2, &byte[0], &enable[0]);
+		mv_pp2x_prs_tcam_data_byte_get(pe, 3, &byte[1], &enable[1]);
+		rvid = ((byte[0] & 0xf) << 8) + byte[1];
+		rmask = ((enable[0] & 0xf) << 8) + enable[1];
+
+		if ((rvid != vid) || (rmask != mask))
+			continue;
+
+		return pe;
+	}
+	kfree(pe);
+
+	return NULL;
+}
+
+int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, bool add)
+{
+	struct mv_pp2x_prs_entry *pe;
+	int tid;
+	int rc;
+	bool empty = false;
+	unsigned int pmap;
+	unsigned int mask = 0xfff;
+	struct mv_pp2x_port *port = netdev_priv(dev);
+	struct mv_pp2x_hw *hw = &port->priv->hw;
+	unsigned int vid_start = MVPP2_PE_VID_FILT_RANGE_START + port->id * MVPP2_PRS_VLAN_FILT_MAX;
+
+	/* Scan TCAM and see if entry with this <vid,port> already exist */
+	pe = mv_pp2x_prs_vid_range_find(hw, (1 << port->id), vid, mask);
+
+	if (vid == 0)
+		/*no need to add vid 0 to HW*/
+		return 0;
+
+	/* No such entry */
+	if (!pe) {
+		if (!add)
+			return 0;
+
+		empty = mv_pp2x_prs_tcam_vid_empty(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX - 2);
+		if (empty) {
+			rc = mv_pp2x_prs_vid_drop_entry_accept(dev, vid_start + MVPP2_PRS_VLAN_FILT_MAX - 1, true);
+			if (rc) {
+				netdev_err(dev, "failed to add default vid entry for non-match vlan packets (drop)\n");
+				return -1;
+			}
+		}
+
+		/* Create new TCAM entry */
+		/* Go through all entries from first to last in vlan range */
+		tid = mv_pp2x_prs_tcam_first_free(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX - 2);
+
+		if (tid < 0)
+			return tid;
+
+		pe = kzalloc(sizeof(*pe), GFP_KERNEL);
+		if (!pe)
+			return -1;
+
+		mv_pp2x_prs_tcam_lu_set(pe, MVPP2_PRS_LU_VID);
+		pe->index = tid;
+
+		/* Mask all ports */
+		mv_pp2x_prs_tcam_port_map_set(pe, 0);
+	}
+
+	/* Update port mask */
+	mv_pp2x_prs_tcam_port_set(pe, port->id, add);
+
+	/* Invalidate the entry if no ports are left enabled */
+	pmap = mv_pp2x_prs_tcam_port_map_get(pe);
+	if (pmap == 0) {
+		if (add) {
+			kfree(pe);
+			return -1;
+		}
+		mv_pp2x_prs_hw_inv(hw, pe->index);
+		hw->prs_shadow[pe->index].valid = false;
+		empty = mv_pp2x_prs_tcam_vid_empty(hw, vid_start, vid_start + MVPP2_PRS_VLAN_FILT_MAX - 2);
+		if (empty) {
+			rc = mv_pp2x_prs_vid_drop_entry_accept(dev, vid_start + MVPP2_PRS_VLAN_FILT_MAX - 1, false);
+			if (rc) {
+				netdev_err(dev, "failed to remove default vid for non-match vlan packets (drop)\n");
+				return -1;
+			}
+		}
+		kfree(pe);
+		return 0;
+	}
+
+	/* Continue - set next lookup */
+	mv_pp2x_prs_sram_next_lu_set(pe, MVPP2_PRS_LU_L2);
+
+	/* Set match on VID */
+	mv_pp2x_prs_match_vid(pe, 2, vid);
+
+	/* Skip VLAN header - Set offset to 4 bytes */
+	mv_pp2x_prs_sram_shift_set(pe, MVPP2_VLAN_TAG_LEN, MVPP2_PRS_SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Update shadow table */
+	mv_pp2x_prs_shadow_set(hw, pe->index, MVPP2_PRS_LU_VID);
+	mv_pp2x_prs_hw_write(hw, pe);
+	kfree(pe);
+	return 0;
+}
+
 int mv_pp2x_prs_tag_mode_set(struct mv_pp2x_hw *hw, int port, int type)
 {
 	switch (type) {
@@ -4045,6 +4282,9 @@ int mv_pp2x_prs_default_init(struct platform_device *pdev,
 	err = mv_pp2x_prs_vlan_init(pdev, hw);
 	if (err)
 		return err;
+
+	mv_pp2x_prs_vid_init(hw);
+
 	err = mv_pp2x_prs_pppoe_init(hw);
 	if (err)
 		return err;
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
index 0ab9265..fa892bd 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw.h
@@ -531,6 +531,9 @@ void mv_pp2x_prs_mac_multi_set(struct mv_pp2x_hw *hw, int port, int index,
 			       bool add);
 int mv_pp2x_prs_mac_da_accept(struct mv_pp2x_port *port,
 			      const u8 *da, bool add);
+
+int mv_pp2x_prs_vid_entry_accept(struct net_device *dev, u16 proto, u16 vid, bool add);
+
 int mv_pp2x_prs_def_flow(struct mv_pp2x_port *port);
 int mv_pp2x_prs_flow_set(struct mv_pp2x_port *port);
 void mv_pp2x_prs_mac_entry_del(struct mv_pp2x_port *port,
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 156705a..0bef1ea 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1297,8 +1297,11 @@ enum mv_pp2x_tag_type {
  * 36 UC/MC MAC filter entries per port
  * It is assumed that there are 3 ports for filter, not including loopback port
  */
-#define MVPP2_PRS_MAC_UC_MC_FILT_MAX	36
-#define MVPP2_PRS_MAC_RANGE_SIZE	113
+#define MVPP2_PRS_MAC_UC_MC_FILT_MAX	25
+#define MVPP2_PRS_MAC_RANGE_SIZE	80
+
+#define MVPP2_PRS_VLAN_FILT_MAX		11
+#define MVPP2_PRS_VLAN_FILT_RANGE_SIZE	33
 
 /* Tcam structure:
  * - lookup ID - 4 bits
@@ -1320,29 +1323,31 @@ enum mv_pp2x_tag_type {
 /* Tcam entries ID */
 #define MVPP2_PE_DROP_ALL		0
 #define MVPP2_PE_FIRST_FREE_TID		1
-#define MVPP2_PE_MAC_RANGE_END		(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
-#define MVPP2_PE_MAC_RANGE_START	(MVPP2_PE_MAC_RANGE_END -\
-					 MVPP2_PRS_MAC_RANGE_SIZE + 1)
+#define MVPP2_PE_MAC_RANGE_END		(MVPP2_PE_VID_FILT_RANGE_START)
+#define MVPP2_PE_MAC_RANGE_START	(MVPP2_PE_MAC_RANGE_END - MVPP2_PRS_MAC_RANGE_SIZE + 1)
+#define MVPP2_PE_VID_FILT_RANGE_END	(MVPP2_PRS_TCAM_SRAM_SIZE - 31)
+#define MVPP2_PE_VID_FILT_RANGE_START	(MVPP2_PE_VID_FILT_RANGE_END - MVPP2_PRS_VLAN_FILT_RANGE_SIZE + 1)
 #define MVPP2_PE_LAST_FREE_TID		(MVPP2_PE_MAC_RANGE_START - 1)
 #define MVPP2_PE_IP6_EXT_PROTO_UN	(MVPP2_PRS_TCAM_SRAM_SIZE - 30)
 #define MVPP2_PE_MAC_MC_IP6		(MVPP2_PRS_TCAM_SRAM_SIZE - 29)
 #define MVPP2_PE_IP6_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 28)
 #define MVPP2_PE_IP4_ADDR_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 27)
 #define MVPP2_PE_LAST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 26)
-#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 19)
-#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 18)
-#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 17)
-#define MVPP2_PE_DSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 16)
-#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 15)
-#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
-#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
-#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
-#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
-#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 10)
-#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 9)
-#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
-#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
-#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
+#define MVPP2_PE_FIRST_DEFAULT_FLOW	(MVPP2_PRS_TCAM_SRAM_SIZE - 20)
+#define MVPP2_PE_EDSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 19)
+#define MVPP2_PE_EDSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 18)
+#define MVPP2_PE_DSA_TAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 17)
+#define MVPP2_PE_DSA_UNTAGGED		(MVPP2_PRS_TCAM_SRAM_SIZE - 16)
+#define MVPP2_PE_ETYPE_EDSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 15)
+#define MVPP2_PE_ETYPE_EDSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 14)
+#define MVPP2_PE_ETYPE_DSA_TAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 13)
+#define MVPP2_PE_ETYPE_DSA_UNTAGGED	(MVPP2_PRS_TCAM_SRAM_SIZE - 12)
+#define MVPP2_PE_MH_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 11)
+#define MVPP2_PE_DSA_DEFAULT		(MVPP2_PRS_TCAM_SRAM_SIZE - 10)
+#define MVPP2_PE_IP6_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 9)
+#define MVPP2_PE_IP4_PROTO_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 8)
+#define MVPP2_PE_ETH_TYPE_UN		(MVPP2_PRS_TCAM_SRAM_SIZE - 7)
+#define MVPP2_PE_VID_FLTR_DEFAULT	(MVPP2_PRS_TCAM_SRAM_SIZE - 6)
 #define MVPP2_PE_VLAN_DBL		(MVPP2_PRS_TCAM_SRAM_SIZE - 5)
 #define MVPP2_PE_VLAN_NONE		(MVPP2_PRS_TCAM_SRAM_SIZE - 4)
 #define MVPP2_PE_MAC_MC_ALL		(MVPP2_PRS_TCAM_SRAM_SIZE - 3)
@@ -1619,6 +1624,7 @@ enum mv_pp2x_prs_lookup {
 	MVPP2_PRS_LU_MAC,
 	MVPP2_PRS_LU_DSA,
 	MVPP2_PRS_LU_VLAN,
+	MVPP2_PRS_LU_VID,
 	MVPP2_PRS_LU_L2,
 	MVPP2_PRS_LU_PPPOE,
 	MVPP2_PRS_LU_IP4,
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 4e04964..28b9bf5 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -3939,6 +3939,22 @@ static int mv_pp2x_dummy_change_mtu(struct net_device *dev, int mtu)
 
 }
 
+static int mv_pp2x_rx_add_vid(struct net_device *dev, u16 proto, u16 vid)
+{
+	int err;
+
+	err = mv_pp2x_prs_vid_entry_accept(dev, proto, vid, true);
+	return err;
+}
+
+static int mv_pp2x_rx_kill_vid(struct net_device *dev, u16 proto, u16 vid)
+{
+	int err;
+
+	err = mv_pp2x_prs_vid_entry_accept(dev, proto, vid, false);
+	return err;
+}
+
 static struct rtnl_link_stats64 *
 mv_pp2x_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
 {
@@ -4061,6 +4077,8 @@ static const struct net_device_ops mv_pp2x_netdev_ops = {
 	.ndo_get_stats64	= mv_pp2x_get_stats64,
 	.ndo_do_ioctl		= mv_pp2x_ioctl,
 	.ndo_set_features	= mv_pp2x_netdev_set_features,
+	.ndo_vlan_rx_add_vid	= mv_pp2x_rx_add_vid,
+	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
 };
 
 static const struct net_device_ops mv_pp2x_non_kernel_netdev_ops = {
@@ -4074,6 +4092,8 @@ static const struct net_device_ops mv_pp2x_non_kernel_netdev_ops = {
 	.ndo_get_stats64	= mv_pp2x_get_stats64,
 	.ndo_do_ioctl		= mv_pp2x_ioctl,
 	.ndo_set_features	= mv_pp2x_netdev_set_features,
+	.ndo_vlan_rx_add_vid	= mv_pp2x_rx_add_vid,
+	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
 };
 
 
@@ -4784,6 +4804,9 @@ skip_tso_buffers:
 
 	dev->vlan_features |= features;
 
+	/* Add support for VLAN filtering */
+	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+
 	dev->priv_flags |= IFF_UNICAST_FLT;
 
 	err = register_netdev(dev);
-- 
1.9.1

