Packet Processor IO (PPIO) User Guide
======================================

1. Introduction
===============

MUSDK PPIO driver and applications are part of the MUSDK package.

MUSDK PPIO driver provides capability of usage of the Packet Processing HW Engine (PP22)
directly from user-space applications with minimum overhead and high performance.

2.  Feature Set
===============

2.1	API Support
------------------------
2.1.1 PP2
---------
	Support all API's _excluding_:
	pp2_deinit()

2.1.2 HIF
---------
	int pp2_hif_init(struct pp2_hif_params *params, struct pp2_hif **hif)
	unsupported:
	void pp2_hif_deinit(struct pp2_hif *hif)

2.1.3 BPOOL
---------
	Support all API's _excluding_:
	void pp2_bpool_deinit(struct pp2_bpool *bpool)

2.1.4 PPIO
----------
	Init:
	-----
	int pp2_ppio_init(struct pp2_ppio_params *params, struct pp2_ppio **ppio);
	int pp2_ppio_enable(struct pp2_ppio *ppio)
	int pp2_ppio_disable(struct pp2_ppio *ppio)
	unsupported:
	void pp2_ppio_deinit(struct pp2_ppio *ppio)

	Send/Receive:
	------------
	int pp2_ppio_send(struct pp2_ppio *ppio, struct pp2_hif *hif, u8 qid, struct pp2_ppio_desc *descs, u16 *num)
	int pp2_ppio_recv(struct pp2_ppio *ppio, u8 tc, u8 qid, struct pp2_ppio_desc *descs, u16 *num)
	int pp2_ppio_get_num_outq_done(struct pp2_ppio *ppio, struct pp2_hif *hif, u8 qid, u16	*num)
	int pp2_ppio_set_mtu(struct pp2_ppio *ppio, u16 mtu)
	int pp2_ppio_get_mtu(struct pp2_ppio *ppio, u16 *mtu)
	int pp2_ppio_set_mru(struct pp2_ppio *ppio, u16 len)
	int pp2_ppio_get_mru(struct pp2_ppio *ppio, u16 *len)
	unsupported:
	int pp2_ppio_send_sg(struct pp2_ppio *ppio, struct pp2_hif *hif, u8 qid, struct pp2_ppio_sg_desc *descs, u16 *num)

	Filtering:
	---------
	int pp2_ppio_set_mac_addr(struct pp2_ppio *ppio, const eth_addr_t addr)
	int pp2_ppio_get_mac_addr(struct pp2_ppio *ppio, eth_addr_t addr)
	int pp2_ppio_set_uc_promisc(struct pp2_ppio *ppio, int en)
	int pp2_ppio_get_uc_promisc(struct pp2_ppio *ppio, int *en)
	int pp2_ppio_set_mc_promisc(struct pp2_ppio *ppio, int en)
	int pp2_ppio_get_mc_promisc(struct pp2_ppio *ppio, int *en)
	int pp2_ppio_add_mac_addr(struct pp2_ppio *ppio, const eth_addr_t addr)
	int pp2_ppio_flush_mac_addrs(struct pp2_ppio *ppio, int uc, int mc)
	int pp2_ppio_add_vlan(struct pp2_ppio *ppio, u16 vlan)
	int pp2_ppio_remove_vlan(struct pp2_ppio *ppio, u16 vlan)
	int pp2_ppio_flush_vlan(struct pp2_ppio *ppio)

	Outqueue:
	--------
	Support all pp2_ppio_outq_xxx API's, _excluding_ :
		void pp2_ppio_outq_desc_set_dsa_tag(struct pp2_ppio_desc *desc)

	Support all pp2_ppio_inq_xxx API's, _excluding_ :
		struct pp2_ppio * pp2_ppio_inq_desc_get_pp_io(struct pp2_ppio_desc *desc)
		int pp2_ppio_inq_desc_get_ip_isfrag(struct pp2_ppio_desc *desc)


2.2	API limitations
-----------------------
	int pp2_init(struct pp2_init_params *params)
		<struct pp2_init_params>
			- 'rss_tbl_reserved_map' is not supported
			- 'ppios[].first_inq' is used, but the version does not support sharing of Linux & musdk sharing a ppio.

	int pp2_ppio_init(struct pp2_ppio_params *params, struct pp2_ppio **ppio)
		<struct pp2_ppio_params>, following are not supported:
			- 'type'
			- 'pkt_offset'
			- 'inqs_params.hash_type'
			- 'inqs_params.tcs_params.use_hash

2.3	Generic Limitations
---------------------------
- In this MUSDK version, the Linux kernel is widely used to bring up Control functionality,
  such as Classification and Link related functionality. It is assumed that interfaces are brought up
  in Linux and not tinkered with afterwards. See '3.2 HOW-TO' for further details.

- The system is initialized with interfaces that are "non-kernel" in the dts.
  These interfaces are reserved for musdk, and only they may be used by musdk.

- Linux interfaces in "non-kernel" state (intended for musdk) :
	- Do not produce a "link up" message, when they are brought up.
	- Do not support being stopped by Linux.
	- Do not support MTU change by Linux.

3.  PKT_ECHO example application
================================

3.1	Functional Overview
---------------------------
- Performs all required initializations, using the MUSDK API's.

	- #define PKT_ECHO_SUPPORT	(default=defined)
		  PKT_ECHO_SUPPORT will scrub the packet_header, by swapping L2 MAC addresses and IPV4 addresses.
		  Without it, pkt_echo application will not touch the packet at all.
	- #define USE_APP_PREFETCH	(default=defined)
		  USE_APP_PREFETCH prefetches the pkt_buffer of a packet that is few packets behind
		  the currently_handled packet in the receive_queue.
		  This significantly improves performance for usecases where packets are being modified.
	- #define PREFETCH_SHIFT	(7)
		  PREFETCH_SHIFT defines the number-of-packets-ahead in the receive_queue that is prefetched.
	- #define HW_BUFF_RECYLC	(default=undefined)
		  This mode makes use of Hardware Buffer Recycling:
		  The buffer of the transmitted packet is returned to the Buffer Manager automatically by Hardware.
		  Example usecase is when the bpool of received packet and the transmitted packet is the same.
	- #define SW_BUFF_RECYLCE	(default=undefined)
		  Mechanism demonstrating use of index_based cookies instead virtual_addresses for buffer_pointers.
	- #define HW_TX_CHKSUM_CALC	(default=undefined)
		  This causes packet_send to request Hardware to perform L3/L4 checksum calculation.


3.2 HOW-TO
----------
	3.2.1 Base Configuration for 8040-DB:
		ifconfig eth0 10.10.10.1 netmask 255.255.255.0 up
		ifconfig eth1 11.11.11.1 netmask 255.255.255.0 up
		ifconfig eth2 12.12.12.1 netmask 255.255.255.0 up
		ifconfig eth3 13.13.13.1 netmask 255.255.255.0 up
		sleep 1
		insmod musdk_uio.ko
		insmod mv_pp_uio.ko
		insmod mvpp2x_sysfs.ko

	3.2.2 Command parameters:
		- '-i eth1' is the linux interface name.
		- '-c 2' stands for two cpus (threads), similar to netmap application.
		- '-m f:1' stands for '<first_thread_cpu_mask>:<mask_shift_for_following_cpus>', similar to netmap application.
		- '-a 1' is the cpu_affinity of the first thread.

	3.2.3 Limitations
		- musdk_pkt_echo cannot be stopped and re-initialized.
		- It is assumed the interface is brought up in Linux before being used by musdk_pkt_echo.

	3.2.4 Examples

		3.2.4.1 Examples for single core, no RSS
		-----------------------------------
			a. 10G eth0 queue 0, cpu_core 3
				./musdk_pkt_echo -i eth0 -a 3

			b. 10G eth2, queue 0, cpu_core 3
				./musdk_pkt_echo -i eth2 -a 3

			c. 10G eth0 <-> eth2, queue 0, cpu_core 3
				./musdk_pkt_echo -i eth0,eth2 -a 3

			d. 1G eth3, queue 0, cpu_core 3
				./musdk_pkt_echo -i eth3 -a 3

		3.2.4.2 Examples for two cores, with RSS
		----------------------------------------
		Additional linux commands configuration:
			ethtool -K eth0 rxhash on
			ethtool -X eth0 equal 2
			ethtool -K eth2 rxhash on
			ethtool -X eth2 equal 2

			a. 10G eth0, queue 0,1, core 1,2
					./musdk_pkt_echo -i eth0 -c 2 -m 1:1 -a 1

			b. 10G eth2, queue 0,1, core 1,2
					./musdk_pkt_echo -i eth2 -c 2 -m 1:1 -a 1

			c. 10G eth0 <-> eth2, queue 0,1 core 1,2
					./musdk_pkt_echo -i eth0,eth2 -c 2 -m 1:1 -a 1


4.  Cls_demo example application
================================
	- The 'musdk_cls_demo' example application allows for configuring 5-tuple table in PPv2 classifier,
	  as well as to configure MAC address filtering,  VLAN filtering and promiscuous mode.
	- For a full description of the application and how to run, please refer to MUSDK classifier 'how-to' section.

